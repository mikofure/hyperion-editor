#!/usr/bin/env bun

import { readFileSync, writeFileSync, existsSync, mkdirSync, statSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

// Get current directory equivalent to Python's __file__
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

function readBinaryFile(filePath: string): Uint8Array {
   // """Read binary file and return as Uint8Array"""
    return new Uint8Array(readFileSync(filePath));
}

function bytesToCppArray(data: Uint8Array, variableName: string): string {
   // """Convert binary data to C++ byte array format"""
    const bytes = Array.from(data).map(byte => `0x${byte.toString(16).padStart(2, '0')}`);
    const chunks: string[] = [];
    
    // Split into lines of 16 bytes each for readability
    for (let i = 0; i < bytes.length; i += 16) {
        const chunk = bytes.slice(i, i + 16).join(', ');
        chunks.push(`    ${chunk}`);
    }
    
    return `const unsigned char ${variableName}[] = {\n${chunks.join(',\n')}\n};\nconst unsigned int ${variableName}_size = ${data.length};`;
}

function generateHeaderFile(outputPath: string): void {
    //"""Generate webapp.hpp header file"""
    const headerContent = `#pragma once

// Auto-generated binary resources from mikobench/dist/index.html
// Do not edit this file manually

// Function to get the HTML content as a C-string
const char* GetWebAppHTML();

// Function to get the size of the HTML content
unsigned int GetWebAppHTMLSize();
`;
    
    writeFileSync(outputPath, headerContent, 'utf-8');
}

function generateCppFile(htmlData: Uint8Array, outputPath: string): void {
    //"""Generate webapp.cpp implementation file"""
    const cppArray = bytesToCppArray(htmlData, 'webapp_html');
    
    const cppContent = `#include "webapp.hpp"

// Auto-generated binary resources from mikobench/dist/index.html
// Do not edit this file manually

${cppArray}

const char* GetWebAppHTML() {
    return reinterpret_cast<const char*>(webapp_html);
}

unsigned int GetWebAppHTMLSize() {
    return webapp_html_size;
}
`;
    
    writeFileSync(outputPath, cppContent, 'utf-8');
}

function main(): void {
    // Get script directory
    const scriptDir = __dirname;
    const projectRoot = join(scriptDir, '..', '..');
    
    // Input file path
    const htmlFile = join(projectRoot, 'webapp', 'dist', 'index.html');
    
    // Output file paths
    const appDir = join(projectRoot, 'app');
    const cppFile = join(appDir, 'webapp.cpp');
    const hppFile = join(appDir, 'webapp.hpp');
    
    // Check if input file exists
    if (!existsSync(htmlFile)) {
        console.error(`Error: Input file not found: ${htmlFile}`);
        console.error("Please build the mikobench project first using 'bun run build'");
        process.exit(1);
    }
    
    // Create app directory if it doesn't exist
    if (!existsSync(appDir)) {
        mkdirSync(appDir, { recursive: true });
    }
    
    console.log(`Reading HTML file: ${htmlFile}`);
    const htmlData = readBinaryFile(htmlFile);
    
    console.log(`Generating header file: ${hppFile}`);
    generateHeaderFile(hppFile);
    
    console.log(`Generating implementation file: ${cppFile}`);
    generateCppFile(htmlData, cppFile);
    
    console.log('\nConversion completed successfully!');
    console.log('Generated files:');
    console.log(`  - ${hppFile} (${statSync(hppFile).size} bytes)`);
    console.log(`  - ${cppFile} (${statSync(cppFile).size} bytes)`);
    console.log(`\nHTML data size: ${htmlData.length} bytes`);
    
    console.log('\nTo use in your C++ code:');
    console.log('  #include "webapp.hpp"');
    console.log('  const char* html = GetWebAppHTML();');
    console.log('  unsigned int size = GetWebAppHTMLSize();');
}

if (import.meta.main) {
    main();
}